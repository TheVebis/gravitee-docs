[[event-native-apim-introduction]]
= Introduction
:page-sidebar: apim_3_x_sidebar
:page-permalink: apim/3.x/event_native_apim_introduction.html
:page-folder: apim/event-native-apim
:page-layout: apim3x

[label label-version]#New in version 3.20.0#
[label label-version]#BETA release#

== Event-driven asynchronous APIs

Most developers are familiar with synchronous APIs, where the client sends a request to a server, and the server sends a response back. Every time the client needs new data, it has to send a request. You can think of synchronous APIs as a 'client pull' model. RESTful APIs are a type of synchronous API.

In contrast, asynchronous APIs are event-driven and allow you to stream data. Asynchronous APIs can use callbacks, such as webhooks, if the requested data is not available at the time of the request. You can think of asynchronous APIs as a 'server push' model. AsyncAPIs are a type of asynchronous API.

== Event-native API management

With the rise of cloud computing, many vendors started to build their solutions for the cloud. Rather than taking on-premises software and converting it to work as SaaS, it was built from the ground to to be cloud-based. These solutions are said to be cloud-native.

Event-native API management is similar. Rather than taking a synchronous API management solution and converting it to handle event-driven APIs, an event-native API management solution is built from the ground up to handle event-driven APIs.

== Gravitee's event-native API management

Gravitee's API management solution can run in event-native mode, and it can support all asynchronous, streaming, and event-driven API use cases. Of course, Gravitee's API management solution also supports synchronous use cases.

Gravitee can act as a bridge between synchronous and asynchronous environments.

For example, Gravitee can subscribe to a Kafka topic and then allow filtered HTTP GET subscriptions from clients as shown in the following diagram.

image:{% link /images/apim/3.x/event-native/event-native-api-management-gateway.png %}[]

== New execution engine (V4 BETA)

Introduced in release 3.19.0 of the Gravitee API Management platform, there is a beta version of a new policy execution engine that enables an improved execution flow for synchronous APIs and supports event-driven policy execution for asynchronous APIs. It is based on a modern and fully reactive architecture designed to address a number of challenges Gravitee users have been facing with the existing policy execution engine, available with the Gravitee's V2 API definition specification used in versions prior to APIM 3.19.x.

The new policy execution engine builds on the new V4 BETA API definition foundation of Gravitee's event-native platform, which adds features such as native support for Pub/Sub (Publish-Subscribe) design and enabling policies at message level. The new V4 BETA event-native API definition makes it possible for the Gateway to “know” what is necessary in order for it to handle asynchronous API use cases.

The new engine provides the following capabilities:

* The ability to execute policies in the exact order in which they have been placed in Policy Studio. This addresses some issues experienced by users related to the order in which policies are executed by the V3 engine where policies interacting with the Head part of the request are always executed first, even when placed in a different order in the Policy Studio during the design phase. With the new execution engine, it is possible to apply logic on a head policy based on the payload of the request - for example, to apply dynamic routing based on the request payload.
* Proper isolation between platform-level policies and API-level policies during policy execution. This ensures that platform-level policies are always executed prior to any API-level policies during the request stage, and after any API-level policies during the response stage.
* Removal of the need to define a scope for policies (`onRequest`, `onRequestContent`, `onResponse`, `onResponseContent`).
* The introduction of new API types to better differentiate REST APIs from Async APIs (Websocket, SSE, Webhook), as a foundation to fully support the execution of Async APIs.

NOTE: This BETA release does not provide GUI support for these capabilities. You can check out the new engine behaviour with the  link:{{ 'apim/3.x/event_native_apim_example_use_cases.html' | relative_url }}[example use cases].

WARNING: The new policy execution engine mode has been released as a BETA version: it should not be used in production. The GA, due in 2023, release will come with additional features - link:https://www.gravitee.io/contact-us[contact us] if you want to know more about it and what new features we are bringing to event-native API Management regarding synchronous and asynchronous APIs.

== BETA Features

The following features are available in the BETA release.

=== HTTP POST and HTTP GET entrypoints

The HTTP POST and HTTP GET entrypoints are Community Edition / OSS plugins that enable external clients to publish and receive data via standard HTTP POST / HTTP GET requests, and ease the ingestion of data into event-orientated backends like Kafka.

With the HTTP POST workflow, a client application running on HTTP can post content to the Gravitee Gateway. The Gateway can then take that content and push it over to Kafka as a message that Kafka can ingest. The Gravitee Gateway acts as a protocol mediation layer in this context. This enables API owners to quickly set up a sync-to-async integration.

The diagram below shows the workflow for this use case:

image:{% link /images/apim/3.x/event-native/event-native-api-management-use-case-http-post.png %}[]

The HTTP POST entrypoint can be used in combination with specific Async API endpoints in different ways, depending on what publish and subscribe mode actions are possible between the two when using a connector. 

=== Support for Websocket and SSE entrypoints

Support for Server-Sent Events (Enterprise Edition only) and Websocket (Community Edition/OSS) entrypoints are provided as separate plugins, available from the link:https://download.gravitee.io/#graviteeio-apim/plugins/entrypoints/[entrypoints plugin download page]

This feature enables you to front your event-driven backend - currently only using Kafka via the Gravitee Community Edition / OSS Kafka connector - with Websocket or Server-Sent Events (SSE) so that API consumers can access events from the Kafka backend via one of these more consumer-friendly protocols.

For example, if an API consumer cannot connect to a native Kafka instance due to technical limitations (for example, if they cannot implement a Kafka client themselves), Kafka topics can be made available to that consumer via a more consumer-friendly protocol such as SSE or Websocket.

The diagram below shows the workflow for this use case:

image:{% link /images/apim/3.x/event-native/event-native-api-management-use-case-event-consumption-streaming.png %}[]

This feature enables you to potentially cover use cases in the fields of Event-Driven Architecture (EDA) and Internet of Things (IoT) without the Gateway and API Management components becoming a bottleneck.

NOTE: In comparison to the link:#http_post_and_http_get_entrypoints[HTTP POST entrypoint use case] using Kafka (where the HTTP POST method is just about sending information from the client app to Kafka), with Websocket it is possible for the client app to send and receive information from Kafka as well. SSE can consume information from Kafka.

=== Webhook entrypoint

This is a feature that enables you to front your backend with a link:https://en.wikipedia.org/wiki/Webhook[Webhook^]. It has CE and EE versions.

With Webhook support, an API consumer subscribes to the Webhook API, which basically indicates to the Gateway to listen for specific Kafka messages and then call the consumer to let them know that an expected event has occurred. This communication is performed via Webhook, however it is always up to the Gateway to push the events or messages to the consumer.

The diagram below shows the workflow for this use case:

image:{% link /images/apim/3.x/event-native/event-native-api-management-use-case-event-consumption-webhook.png %}[]

=== Security policies

The following security policies have been implemented:

* API Key: enforces API key checks during request processing (for security).
* Keyless policy: does not block any requests as it considers them as valid by default.
* JWT: generates a signed JWT with a configurable set of claims. This JWT can subsequently be forwarded to backend targets, or used in some other context.
* OAuth: checks access token validity during request processing using token introspection (for security).