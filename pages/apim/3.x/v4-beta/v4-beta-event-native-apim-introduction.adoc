[[v4-beta-event-native-apim-introduction]]
= Introduction
:page-sidebar: apim_3_x_sidebar
:page-permalink: apim/3.x/event_native_apim_introduction.html
:page-folder: apim/v4-beta
:page-layout: apim3x

[label label-version]#New in version 3.20.0#
[label label-version]#BETA release#

== Event-driven asynchronous APIs

Most developers are familiar with synchronous APIs, where the client sends a request to a server, and the server sends a response back. Every time the client needs new data, it has to send a request. You can think of synchronous APIs as a 'client pull' model. RESTful APIs are a type of synchronous API.

In contrast, asynchronous APIs are event-driven - the initial request opens a connection and data (responses) is received back as and when it becomes available, where certain events would trigger the responses. Asynchronous APIs also allow you to stream data - a common use case in banking and finance systems and applications, as well as many other domains. Asynchronous APIs can use callbacks (such as synchronous API webhooks) if the requested data is not available at the time of the request. You can think of asynchronous APIs as a ‘server push’ model. AsyncAPIs are a type of asynchronous API.

== Event-native API management

With the rise of cloud computing, many vendors started to build their solutions for the cloud. Rather than taking on-premises software and converting it to work as SaaS, it was built from the ground to to be cloud-based. These solutions are said to be cloud-native.

Event-native API management is similar. Rather than taking a synchronous API management solution and converting it to handle event-driven APIs, an event-native API management solution is built from the ground up to handle event-driven APIs.

== Gravitee's event-native API management

Gravitee's API management solution can run in event-native mode, and it can support all asynchronous, streaming, and event-driven API use cases. Of course, Gravitee's API management solution also supports synchronous use cases.

Gravitee can act as a bridge between synchronous and asynchronous environments.

For example, Gravitee can subscribe to a Kafka topic and then allow filtered HTTP GET subscriptions from clients as shown in the following diagram.

image:{% link /images/apim/3.x/event-native/event-native-api-management-gateway.png %}[]

== BETA Features

The following features are available in the BETA release.

=== HTTP POST and HTTP GET entrypoints

The HTTP POST and HTTP GET entrypoints are Community Edition / OSS plugins that enable external clients to publish and receive data via standard HTTP POST / HTTP GET requests, and ease the ingestion of data into event-oriented backends like Kafka.

With the HTTP POST workflow, a client application running on HTTP can post content to the Gravitee Gateway. The Gateway can then take that content and push it over to Kafka as a message that Kafka can ingest. The Gravitee Gateway acts as a protocol mediation layer in this context. This enables API owners to quickly set up a sync-to-async integration.

The diagram below shows the workflow for this use case:

image:{% link /images/apim/3.x/event-native/event-native-api-management-use-case-http-post.png %}[]

The HTTP POST entrypoint enables you to push messages to any supported event broker via a "sync call" (post) - it can be used in combination with specific Asynchronous API endpoints in different ways, depending on what publish and subscribe mode actions are possible between the two when using a connector.

=== Support for Websocket and SSE entrypoints

Support for Server-Sent Events (Enterprise Edition only) and Websocket (Community Edition/OSS) entrypoints are provided as separate plugins, available from the link:https://download.gravitee.io/#graviteeio-apim/plugins/entrypoints/[entrypoints plugin download page]

This feature enables you to front your event-driven backend - currently only using Kafka or the MQTT5 connectors  - with Websocket or Server-Sent Events (SSE) so that API consumers can access events from the Kafka backend via one of these more consumer-friendly protocols.

For example, if an API consumer cannot connect to a native Kafka instance due to technical limitations (for example, if they cannot implement a Kafka client themselves), Kafka topics can be made available to that consumer via a more consumer-friendly protocol such as SSE or Websocket.

The diagram below shows the workflow for this use case:

image:{% link /images/apim/3.x/event-native/event-native-api-management-use-case-event-consumption-streaming.png %}[]

This feature enables you to potentially cover use cases in the fields of Event-Driven Architecture (EDA) and Internet of Things (IoT) without the Gateway and API Management components becoming a bottleneck.

NOTE: In comparison to the link:#http_post_and_http_get_entrypoints[HTTP POST entrypoint use case] using Kafka (where the HTTP POST method is just about sending information from the client app to Kafka), with Websocket it is possible for the client app to send and receive information from Kafka as well. SSE can consume information from Kafka.

=== Webhook entrypoint

This is a feature that enables you to front your backend with a link:https://en.wikipedia.org/wiki/Webhook[Webhook^]. It has CE and EE versions.

With Webhook support, an API consumer subscribes to the Webhook API, which basically indicates to the Gateway to listen for specific Kafka messages and then call the consumer to let them know that an expected event has occurred. This communication is performed via Webhook, however it is always up to the Gateway to push the events or messages to the consumer.

The diagram below shows the workflow for this use case:

image:{% link /images/apim/3.x/event-native/event-native-api-management-use-case-event-consumption-webhook.png %}[]

=== Security policies

As with the previous version, the following security policies have been implemented:

* API Key: enforces API key checks during request processing (for security).
* Keyless policy: does not block any requests as it considers them as valid by default.
* JWT: generates a signed JWT with a configurable set of claims. This JWT can subsequently be forwarded to backend targets, or used in some other context.
* OAuth: checks access token validity during request processing using token introspection (for security).
